use crate::{
    instr::Instr,
    opc::{BinOpKind, Op, UnOpKind},
    sifv::SifVal,
};

use sifc_err::compile_err::{CompileErr, CompileErrTy};

use sifc_parse::{
    ast::AstNode,
    token::{Token, TokenTy},
};

use std::collections::HashMap;

/// CompileResult contains information generated by the compiler after
/// compilation is completed.
// TODO: might need to use &Instr instead
pub struct CompileResult {
    /// Vector containing the sequential, linear 3 address code for
    /// a vm to execute.
    pub code: Vec<Instr>,

    /// Jump table that maps label indices to code indices. When you look
    /// up a label index, this returns the index of the first instruction
    /// under than label. Both indices being at 0. For example:
    ///
    /// lbl0:
    ///     stc 10 r0
    ///     stc 11 r1
    /// lbl1:
    ///     add r0 r1 r2
    ///
    /// If we call jumptab.get(0), it would return 0. If we call jumptab.get(1),
    /// we would get back 2, since the third (index 2) instruction is the first under
    /// lbl1.
    /// This requires a separate pass to compute, after the initial compilation phase
    /// which generates instructions and labels.
    pub jumptab: HashMap<usize, usize>,

    /// Any errors that were encountered during compilation. The compiler does not
    /// attempt to continue on any error, it should exit immediately upon error.
    pub err: Option<CompileErr>,
}

pub struct Compiler<'c> {
    /// Ast supplied by the parser, assumed to be correct.
    ast: &'c AstNode,

    /// Vector of instructions which the compiler will prepare and fill.
    /// This refers to the code section of the vm layout. It's size should be
    /// known before interpreting begins.
    ops: Vec<Instr>,

    /// Current number of labels in the block being translated.
    lblcnt: usize,

    /// Current available register
    ri: usize,
}

impl<'c> Compiler<'c> {
    pub fn new(a: &'c AstNode) -> Compiler<'c> {
        Compiler {
            ast: a,
            ops: Vec::new(),
            lblcnt: 0,
            ri: 0,
        }
    }

    pub fn compile(&mut self) -> CompileResult {
        let mut currerr = None;

        match self.ast {
            AstNode::Program { blocks } => {
                self.blocks(blocks.to_vec());

                // TODO: we need this for labeling purposes right now, but
                // could probably remove it later
                self.newlbl();
                self.push_op(Op::Nop);
            }
            _ => currerr = Some(CompileErr::new(CompileErrTy::InvalidAst)),
        };

        let jumptab = crate::jumptab::compute_jumptab(&self.ops);

        CompileResult {
            code: self.ops.to_vec(),
            jumptab: jumptab,
            err: currerr,
        }
    }

    pub fn blocks(&mut self, blocks: Vec<AstNode>) {
        for block in blocks {
            self.block(&block);
        }
    }

    pub fn block(&mut self, block: &AstNode) {
        match block {
            AstNode::Block { decls, .. } => self.decls(decls),
            AstNode::ExprStmt { expr } => self.expr(expr),
            AstNode::VarDecl {
                ident_tkn,
                is_global: _,
                lhs,
            } => self.vardecl(ident_tkn, lhs.clone()),
            AstNode::IfStmt {
                cond_expr,
                if_stmts,
                elif_exprs,
                else_stmts,
            } => self.ifstmt(
                cond_expr,
                if_stmts,
                elif_exprs.to_vec(),
                else_stmts.to_vec(),
            ),
            AstNode::ForStmt {
                var_list,
                in_expr_list,
                stmts,
            } => self.forstmt(var_list, in_expr_list, stmts),
            AstNode::ArrayDecl {
                ident_tkn, body, ..
            } => self.arraydecl(ident_tkn, body),
            _ => {
                // generate nothing if we find some unknown block
            }
        }
    }

    pub fn lblcnt(&self) -> usize {
        self.lblcnt
    }

    pub fn newlbl(&mut self) {
        self.lblcnt = self.lblcnt + 1;
    }

    pub fn buildlbl(&self, cnt: usize) -> String {
        format!("lbl{}", cnt)
    }

    pub fn currlbl(&self) -> String {
        format!("lbl{}", self.lblcnt)
    }

    pub fn nextreg(&mut self) -> usize {
        let reg = self.ri;
        self.ri = self.ri + 1;
        reg
    }

    pub fn prevreg(&mut self) -> usize {
        if self.ri == 0 {
            return 0;
        }

        self.ri - 1
    }

    pub fn push_op(&mut self, op: Op) {
        let i = Instr::new(self.lblcnt, op, self.ops.len() + 1);
        self.ops.push(i);
    }

    pub fn expr(&mut self, expr: &AstNode) {
        match expr {
            AstNode::BinaryExpr { op_tkn, lhs, rhs } => match op_tkn.ty {
                TokenTy::Plus => self.binop(BinOpKind::Add, lhs, rhs),
                TokenTy::Minus => self.binop(BinOpKind::Sub, lhs, rhs),
                TokenTy::Star => self.binop(BinOpKind::Mul, lhs, rhs),
                TokenTy::Slash => self.binop(BinOpKind::Div, lhs, rhs),
                TokenTy::Percent => self.binop(BinOpKind::Modu, lhs, rhs),
                TokenTy::EqEq => self.binop(BinOpKind::Eq, lhs, rhs),
                TokenTy::LtEq => self.binop(BinOpKind::LtEq, lhs, rhs),
                TokenTy::Lt => self.binop(BinOpKind::Lt, lhs, rhs),
                TokenTy::GtEq => self.binop(BinOpKind::GtEq, lhs, rhs),
                TokenTy::Gt => self.binop(BinOpKind::Gt, lhs, rhs),
                TokenTy::AmpAmp => self.binop(BinOpKind::Land, lhs, rhs),
                TokenTy::PipePipe => self.binop(BinOpKind::Lor, lhs, rhs),
                TokenTy::BangEq => self.binop(BinOpKind::Lnot, lhs, rhs),
                _ => (),
            },
            AstNode::LogicalExpr { op_tkn, lhs, rhs } => match op_tkn.ty {
                TokenTy::EqEq => self.binop(BinOpKind::Eq, lhs, rhs),
                TokenTy::LtEq => self.binop(BinOpKind::LtEq, lhs, rhs),
                TokenTy::Lt => self.binop(BinOpKind::Lt, lhs, rhs),
                TokenTy::GtEq => self.binop(BinOpKind::GtEq, lhs, rhs),
                TokenTy::Gt => self.binop(BinOpKind::Gt, lhs, rhs),
                TokenTy::AmpAmp => self.binop(BinOpKind::Land, lhs, rhs),
                TokenTy::PipePipe => self.binop(BinOpKind::Lor, lhs, rhs),
                TokenTy::BangEq => self.binop(BinOpKind::Lnot, lhs, rhs),
                _ => (),
            },
            AstNode::UnaryExpr { op_tkn, rhs } => match op_tkn.ty {
                TokenTy::Bang => self.unop(UnOpKind::Lneg, rhs),
                TokenTy::Minus => self.unop(UnOpKind::Nneg, rhs),
                _ => (),
            },
            AstNode::VarAssignExpr {
                ident_tkn,
                is_global: _,
                rhs,
            } => {
                let st_name = ident_tkn.get_name();
                self.assign(st_name, rhs);
            }
            AstNode::PrimaryExpr { .. } => {
                // PrimaryExpr by itself does not generate anything
            }
            _ => (),
        }
    }

    fn binop(&mut self, kind: BinOpKind, lhs: &AstNode, rhs: &AstNode) {
        let r0 = self.binarg(lhs);
        let r1 = self.binarg(rhs);

        let op = Op::Binary {
            kind: kind,
            src1: r0,
            src2: r1,
            dest: self.nextreg(),
        };
        self.push_op(op);
    }

    fn unop(&mut self, kind: UnOpKind, rhs: &AstNode) {
        let r0 = self.binarg(rhs);
        let op = Op::Unary {
            kind: kind,
            src1: r0,
            dest: self.nextreg(),
        };
        self.push_op(op);
    }

    // Returns the index of the register in which the last stored value is
    fn binarg(&mut self, arg: &AstNode) -> usize {
        match arg {
            AstNode::PrimaryExpr { tkn } => match &tkn.ty {
                TokenTy::Val(v) => {
                    let sifv = SifVal::Num(*v);
                    let d = self.nextreg();
                    let op = Op::LoadC { dest: d, val: sifv };
                    self.push_op(op);
                }
                TokenTy::True => {
                    let d = self.nextreg();
                    let sifv = SifVal::Bl(true);
                    let op = Op::LoadC { dest: d, val: sifv };
                    self.push_op(op);
                }
                TokenTy::False => {
                    let d = self.nextreg();
                    let sifv = SifVal::Bl(false);
                    let op = Op::LoadC { dest: d, val: sifv };
                    self.push_op(op);
                }
                TokenTy::Ident(i) => {
                    let d = self.nextreg();
                    let op = Op::LoadN {
                        dest: d,
                        name: i.clone(),
                    };
                    self.push_op(op);
                }
                _ => {}
            },
            _ => {
                self.expr(arg);
            }
        };
        self.ri - 1
    }

    fn decls(&mut self, decls: &Vec<AstNode>) {
        for decl in decls {
            match decl {
                AstNode::ExprStmt { expr } => {
                    self.expr(expr);
                }
                AstNode::VarDecl {
                    ident_tkn,
                    is_global: _,
                    lhs,
                } => self.vardecl(ident_tkn, lhs.clone()),
                _ => (),
            }
        }
    }

    fn vardecl(&mut self, tkn: &Token, rhs: Option<Box<AstNode>>) {
        let st_name = tkn.get_name();
        if rhs.is_none() {
            // We generate a store for an empty value here, to ensure that the name is present
            // in memory if we try to assign to it later. We can detect null value accesses at some
            // point if we want to, or we can leave it to runtime.
            let op = Op::StoreC {
                val: SifVal::Null,
                name: st_name,
            };
            self.push_op(op);
            return;
        }

        self.assign(st_name, &rhs.unwrap());
    }

    pub fn assign(&mut self, st_name: String, rhs: &AstNode) {
        match rhs {
            AstNode::PrimaryExpr { tkn } => {
                match &tkn.ty {
                    TokenTy::Val(v) => {
                        let op = Op::StoreC {
                            val: SifVal::Num(*v),
                            name: st_name,
                        };
                        self.push_op(op);
                    }
                    TokenTy::Str(s) => {
                        let op = Op::StoreC {
                            val: SifVal::Str(s.clone()),
                            name: st_name,
                        };
                        self.push_op(op);
                    }
                    TokenTy::Ident(i) => {
                        let op = Op::StoreN {
                            srcname: i.clone(),
                            destname: st_name,
                        };
                        self.push_op(op);
                    }
                    _ => {}
                };
            }
            _ => {
                // We assume that if we aren't assigning a declaration to a constant, we are using an
                // expression. We store based on the correct register from the expression.
                self.expr(&rhs);
                let op = Op::StoreR {
                    name: st_name,
                    src: self.prevreg(),
                };
                self.push_op(op);
            }
        };
    }
}
