
prog       ::= { decl } ;
decl       ::= vardecl    |
               funcdecl   |
	       recorddecl |
	       tabledecl  |
	       arraydecl  |
	       { stmt }   ;
stmt       ::= ifstmt   |
               forstmt  |
	       exprstmt |
	       retstmt  |
	       block    ;
block      ::= "{" { decl } "}" ;

identpair  ::= IDENT "," IDENT ;
varlist   ::= { IDENT [ "=" expr ] "," } ;
itemlist   ::= { IDENT "=>" expr "," } ;
paramlist  ::= [ { IDENT [ "," ] } ] ;

vardecl    ::= "let" IDENT [ "=" expr ] ";" ;
funcdecl   ::= "fn" IDENT "(" [ paramlist ] ")" block ;
recorddecl ::= "record" IDENT "{" [ varlist ] "}" ;
tabledecl  ::= "table" IDENT "{" [ itemlist ] "}" ;
arraydecl  ::= "array" IDENT "[" expr "]" ";" ;

ifstmt     ::= "if" expr block { "elif" expr block } [ "else" block ] ;
forstmt    ::= "for" identpair "in" expr block ;
exprstmt   ::= expr ";" ;
retstmt    ::= "return" [ expr ] ";" ;

funccall   ::= primary "(" [ paramlist ] ")" ;
tablecall  ::= primary "." primary ;
arraycall  ::= primary "[" expr "]" ;
recordcall ::= primary "->" primary ";" ;

expr         ::= assignexpr ;
assignexpr   ::= [ { [ funccall "." ] [ tablecall ] } ] assignexpr | orexpr ;
orexpr       ::= andexpr { [ "||" ] andexpr } ;
andexpr      ::= eqexpr { [ "&&" ] eqexpr } ;
eqexpr       ::= cmpexpr { [ "!=" ] [ "==" ] cmpexpr } ;
cmpexpr      ::= addorsubexpr { [ ">" ] [ ">=" ] [ "<" ] [ "<=" ] addorsubexpr } ;
addorsubexpr ::= mulordivexpr { [ "+" ] [ "-" ] mulordivexpr } ;
mulordivexpr ::= modexpr { [ "*" ] [ "/" ] modexpr } ;
modexpr      ::= unaryexpr { [ "%" ] unaryexpr } ;
unaryexpr    ::= [ "-" ]  [ "!" ] unaryexpr | funccall | tablecall | recordcall | arraycall ;
primary      ::= NUMBER |
                 STRING |
	         TRUE   |
	         FALSE  |
	         IDENT  |
	         groupexpr ;
groupexpr    ::= "(" expr ")" ;
